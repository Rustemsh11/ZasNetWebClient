@using ZasNetWebClient.Models
@inject NavigationManager Navigation
@inject IJSRuntime JSRuntime

<div class="calendar-container">
    <div class="calendar-header">
        <div class="calendar-nav">
            <button class="btn-nav" @onclick="PreviousDay" title="Предыдущий день">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <polyline points="15 18 9 12 15 6"></polyline>
                </svg>
            </button>
            <h2 class="calendar-title">@CurrentDate.ToString("dd MMMM yyyy")</h2>
            <button class="btn-nav" @onclick="NextDay" title="Следующий день">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <polyline points="9 18 15 12 9 6"></polyline>
                </svg>
            </button>
            <button class="btn-today" @onclick="GoToToday">Сегодня</button>
            <button class="btn-date" @onclick="ShowDatePicker">Перейти к дате</button>
        </div>
    </div>

    @if (showDatePicker)
    {
        <div class="date-picker-overlay" @onclick="HideDatePicker">
            <div class="date-picker" @onclick:stopPropagation="true">
                <h3>Выберите дату</h3>
                <InputDate @bind-Value="selectedDate" class="date-input" />
                <div class="date-picker-buttons">
                    <button class="btn-primary" @onclick="GoToSelectedDate">Перейти</button>
                    <button class="btn-secondary" @onclick="HideDatePicker">Отмена</button>
                </div>
            </div>
        </div>
    }

    <div class="calendar-timeline" @ref="timelineContainer">
        <div class="calendar-timeline-header">
            <div class="car-header">Машина</div>
            <div class="hours-header" @ref="hoursHeader">
                @for (int hour = 0; hour <= 24; hour++)
                {
                    <div class="hour-cell">@hour</div>
                }
            </div>
        </div>
        <div class="calendar-timeline-body">
            @foreach (var carGroup in carGroups)
            {
                <div class="car-row">
                    <div class="car-name">@carGroup.CarName</div>
                    <div class="hours-row">
                        @for (int hour = 0; hour <= 24; hour++)
                        {
                            <div class="hour-cell" data-hour="@hour"></div>
                        }
                        @foreach (var order in carGroup.Orders)
                        {
                            <div class="order-block" 
                                 style="@(GetOrderStyle(order))"
                                 title="@GetOrderTooltip(order)"
                                 @ondblclick="@(() => OpenOrder(order.Id))">
                                <div class="order-content">
                                    <div class="order-time">@GetOrderTimeRange(order)</div>
                                    <div class="order-client">@order.Client</div>
                                    @if (!string.IsNullOrEmpty(order.Address))
                                    {
                                        <div class="order-address">@order.Address</div>
                                    }
                                </div>
                            </div>
                        }
                    </div>
                </div>
            }
        </div>
    </div>
</div>

@code {
    [Parameter]
    public List<Order> Orders { get; set; } = new();

    [Parameter]
    public List<CarDto> AllCars { get; set; } = new();

    private DateTime CurrentDate = DateTime.Today;
    private bool showDatePicker = false;
    private DateTime selectedDate = DateTime.Today;

    private List<CarOrderGroup> carGroups = new();
    private ElementReference timelineContainer;
    private ElementReference hoursHeader;
    private bool shouldScrollToHour8 = true;

    protected override void OnParametersSet()
    {
        BuildCalendar();
        shouldScrollToHour8 = true;
        StateHasChanged();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (shouldScrollToHour8)
        {
            // Увеличиваем задержку и добавляем несколько попыток для надежности
            await Task.Delay(100);
            await ScrollToHour(6);
            // Повторная попытка через небольшую задержку для надежности
            await Task.Delay(100);
            await ScrollToHour(6);
            shouldScrollToHour8 = false;
        }
        
        // При первом рендере также прокручиваем к 8 часу
        if (firstRender)
        {
            await Task.Delay(200);
            await ScrollToHour(6);
        }
    }

    private void BuildCalendar()
    {
        carGroups.Clear();

        // Get orders for the current date
        var dayOrders = Orders.Where(o => o.DateStart.Date == CurrentDate.Date).ToList();

        // Group orders by car ID
        var ordersByCarId = new Dictionary<int, List<Order>>();
        var ordersWithoutCar = new List<Order>();
        
        foreach (var order in dayOrders)
        {
            if (order.CarIds != null && order.CarIds.Count > 0)
            {
                // Add order to each car it's assigned to
                foreach (var carId in order.CarIds)
                {
                    if (!ordersByCarId.ContainsKey(carId))
                    {
                        ordersByCarId[carId] = new List<Order>();
                    }
                    ordersByCarId[carId].Add(order);
                }
            }
            else
            {
                // Order without cars
                ordersWithoutCar.Add(order);
            }
        }

        // Sort orders within each car group
        foreach (var carId in ordersByCarId.Keys.ToList())
        {
            ordersByCarId[carId] = ordersByCarId[carId].OrderBy(o => o.DateStart).ToList();
        }
        ordersWithoutCar = ordersWithoutCar.OrderBy(o => o.DateStart).ToList();

        // Create groups for all cars from AllCars
        if (AllCars != null && AllCars.Count > 0)
        {
            foreach (var car in AllCars.OrderBy(c => c.Name))
            {
                var carOrders = ordersByCarId.ContainsKey(car.Id) 
                    ? ordersByCarId[car.Id] 
                    : new List<Order>();
                
                carGroups.Add(new CarOrderGroup
                {
                    CarName = car.Name,
                    Orders = carOrders
                });
            }
        }

        // Add cars from orders that are not in AllCars (by ID)
        foreach (var carId in ordersByCarId.Keys)
        {
            if (AllCars == null || !AllCars.Any(c => c.Id == carId))
            {
                // Car ID exists in orders but not in AllCars - use ID as name
                carGroups.Add(new CarOrderGroup
                {
                    CarName = $"Машина #{carId}",
                    Orders = ordersByCarId[carId]
                });
            }
        }

        // Add orders without cars
        if (ordersWithoutCar.Count > 0)
        {
            carGroups.Add(new CarOrderGroup
            {
                CarName = "Без машины",
                Orders = ordersWithoutCar
            });
        }

        // If no cars at all, show a message
        if (carGroups.Count == 0)
        {
            carGroups.Add(new CarOrderGroup
            {
                CarName = "Нет машин",
                Orders = new List<Order>()
            });
        }
    }

    private void PreviousDay()
    {
        CurrentDate = CurrentDate.AddDays(-1);
        BuildCalendar();
        shouldScrollToHour8 = true;
        StateHasChanged();
    }

    private void NextDay()
    {
        CurrentDate = CurrentDate.AddDays(1);
        BuildCalendar();
        shouldScrollToHour8 = true;
        StateHasChanged();
    }

    private void GoToToday()
    {
        CurrentDate = DateTime.Today;
        BuildCalendar();
        shouldScrollToHour8 = true;
        StateHasChanged();
    }

    private void ShowDatePicker()
    {
        selectedDate = CurrentDate;
        showDatePicker = true;
        StateHasChanged();
    }

    private void HideDatePicker()
    {
        showDatePicker = false;
        StateHasChanged();
    }

    private void GoToSelectedDate()
    {
        CurrentDate = selectedDate.Date;
        BuildCalendar();
        HideDatePicker();
        shouldScrollToHour8 = true;
        StateHasChanged();
    }

    private async Task ScrollToHour(int hour)
    {
        try
        {
            // Прокручиваем к позиции указанного часа
            // Каждый час занимает 1/25 от общей ширины (25 столбцов: 0-24)
            // Позиция 8 часов = 8/25 = 32% от общей ширины
            var scrollPercent = (hour / 25.0) * 100;
            
            // Прокручиваем контейнер timeline, так как у него overflow-x: auto
            await JSRuntime.InvokeVoidAsync("scrollToHour", timelineContainer, scrollPercent);
        }
        catch
        {
            // Игнорируем ошибки прокрутки
        }
    }

    private void OpenOrder(int orderId)
    {
        if (orderId > 0)
        {
            Navigation.NavigateTo($"/order/{orderId}");
        }
    }

    private string GetOrderStyle(Order order)
    {
        var startHour = order.DateStart.Hour;
        var startMinute = order.DateStart.Minute;
        var startPosition = startHour + (startMinute / 60.0);

        var endHour = order.DateEnd?.Hour ?? order.DateStart.AddHours(1).Hour;
        var endMinute = order.DateEnd?.Minute ?? order.DateStart.AddMinutes(60).Minute;
        var endPosition = endHour + (endMinute / 60.0);

        var duration = endPosition - startPosition;
        if (duration <= 0) duration = 1; // Minimum 1 hour

        // У нас 25 столбцов (0-24), поэтому делим на 25
        // Используем InvariantCulture для корректного форматирования чисел
        var leftPercent = (startPosition / 25.0) * 100;
        var widthPercent = (duration / 25.0) * 100;

        var backgroundColor = GetStatusColor(order.Status);

        // Формируем стиль с правильным форматированием
        // Используем InvariantCulture для гарантии точки в качестве разделителя
        return string.Format(
            System.Globalization.CultureInfo.InvariantCulture,
            "left: {0:F2}%; width: {1:F2}%; background-color: {2};",
            leftPercent,
            widthPercent,
            backgroundColor
        );
    }

    private string GetOrderTimeRange(Order order)
    {
        var start = order.DateStart.ToString("HH:mm");
        if (order.DateEnd.HasValue)
        {
            var end = order.DateEnd.Value.ToString("HH:mm");
            return $"{start} - {end}";
        }
        return start;
    }

    private string GetOrderTooltip(Order order)
    {
        var tooltip = $"{order.Client}\n";
        if (!string.IsNullOrEmpty(order.Address))
        {
            tooltip += $"Адрес: {order.Address}\n";
        }
        return tooltip;
    }

    private string GetStatusColor(OrderStatus status)
    {
        return status switch
        {
            OrderStatus.Created => "#e3f2fd",
            OrderStatus.ApprovedWithEmployers => "#c6f500",
            OrderStatus.Processing => "#fff3e0",
            OrderStatus.Finished => "#e8f5e9",
            OrderStatus.CreatingInvoice => "#f3e5f5",
            OrderStatus.AwaitingPayment => "#fff9c4",
            OrderStatus.Closed => "#eceff1",
            _ => "#f5f5f5"
        };
    }

    private string GetStatusName(OrderStatus status)
    {
        return status switch
        {
            OrderStatus.Created => "Создана",
            OrderStatus.ApprovedWithEmployers => "Одобрена сотрудниками",
            OrderStatus.Processing => "В работе",
            OrderStatus.Finished => "Завершена",
            OrderStatus.CreatingInvoice => "Создание счета",
            OrderStatus.AwaitingPayment => "Ожидание оплаты",
            OrderStatus.Closed => "Закрыта",
            _ => "Неизвестно"
        };
    }

    private class CarOrderGroup
    {
        public string CarName { get; set; } = string.Empty;
        public List<Order> Orders { get; set; } = new();
    }
}
